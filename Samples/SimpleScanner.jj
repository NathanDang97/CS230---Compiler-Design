
/*
 * A very simple grammar for very simple tokens.
 * The tokens here are just addops and single-letter identifiers.
 * E.g., the output for this file:
      abbjdkls
        d jfll f+ + -
        +
      ++++++
   is as follows:
        Type            Lexeme
        <IDENTIFIER>    a
        <IDENTIFIER>    b
        <IDENTIFIER>    b
        <IDENTIFIER>    j
        <IDENTIFIER>    d
        <IDENTIFIER>    k
        <IDENTIFIER>    l
        <IDENTIFIER>    s
        <IDENTIFIER>    d
        <IDENTIFIER>    j
        <IDENTIFIER>    f
        <IDENTIFIER>    l
        <IDENTIFIER>    l
        <IDENTIFIER>    f
        <ADDOP>         +
        <ADDOP>         +
        <ADDOP>         -
        <ADDOP>         +
        <ADDOP>         +
        <ADDOP>         +
        <ADDOP>         +
        <ADDOP>         +
        <ADDOP>         +
        <ADDOP>         +
 */

/*
   NOTES ON USING THIS FILE:
      (1) Store in a convenient directory.
      (2) At the command line, type "javacc Lexer.jj"
      (3) At the command line, type "javac Lexer.java"
      (4) To run, type "java Lexer <inputfilename>".
   It's easy to leave out step 3! The file Lexer.java is
   automatically generated by javacc, but is *not* automatically
   compiled by it!
   NB: The *name* of the file Lexer.java comes from the name of
   the *class* Lexer in this file. Even if you change the name
   of this file, unless you change the name of the Lexer class below,
   javacc will still generate a file entitled Lexer.java.
 */

PARSER_BEGIN(Lexer)

//This part of the code is just plain java.
//The "Lexer" class is an executable class with a main method.
//It creates a Lexer object named "parser" and invokes its "Input()" method.
//The Input() method is defined in the grammar as a "nonterminal symbol."
//The printToken() method, defined in the class, is *used* in the grammar.

import java.io.*;

public class Lexer {

  public static void main(String args[]) throws ParseException, FileNotFoundException {
    Lexer parser = new Lexer(new FileInputStream (args[0]));
    parser.Input();
  }
  
  //printToken() prints the token t given in the parameters.
  //The t.image gives the lexeme of the token; "image" is an instance
  //variable in the (built-in) class Token.
  public static void printToken (Token t, String type)
  { 
    if (type.equals("<KEYWORD>"))
        System.out.println("\t" + type + "\t\t" + t.image);
    else if (type.equals("<BEGIN>"))
        System.out.println("\t" + type + "\t\t\t" + t.image);
    else if (type.equals("<END>"))
        System.out.println("\t" + type + "\t\t\t" + t.image);
    else if (type.equals("<ADDOP>"))
        System.out.println("\t" + type + "\t\t\t" + t.image);
    else if (type.equals("<MULTOP>"))
        System.out.println("\t" + type + "\t\t" + t.image);
    else if (type.equals("<ASSIGNOP>"))
        System.out.println("\t" + type + "\t\t" + t.image);
    else if (type.equals("<SEMICOLON>"))
        System.out.println("\t" + type + "\t\t" + t.image);
    else if (type.equals("<OPENPAREN>"))
        System.out.println("\t" + type + "\t\t" + t.image);
    else if (type.equals("<CLOSEPAREN>"))
        System.out.println("\t" + type + "\t\t" + t.image);
    else if (type.equals("<IDENTIFIER>"))
        System.out.println("\t" + type + "\t\t" + t.image);
   }
}

PARSER_END(Lexer)

/*  Specification of tokens */

//Here we specify the whitespace that is skipped.
SKIP :
{
  " "
  | "\t"
  | "\n"
  | "\r"
}

//Here the token classes (ADDOP and IDENTIFIER) are defined along
//with the explicit lexemes.
TOKEN :
{ <KEYWORD: "void" | "main">
 | <ADDOP: "+" | "-" >
 | <MULTOP: "*" | "/" | "%">
 | <ASSIGNOP: "=">
 | <SEMICOLON: ";">
 | <OPENPAREN: "(">
 | <CLOSEPAREN: ")">
 | <BEGIN: "{">
 | <END: "}">
 | <IDENTIFIER: ["a"-"z"](["a"-"z"] | ["0" - "9"])*>
}

/* Specification of Language */

//The Input() symbol is just a wrapper for the Program() symbol.
//It prints out a header ("Type     Lexeme") for the list that
//is ultimately printed out by Program().
void Input() :
{ }
{
 {System.out.println("\t" + "Type\t\t\t" + "Lexeme");}
 Program() <EOF>
}

//Program() is the legit start symbol for this grammar. At this point,
//we just regard it as a string of tokens, as specified above.
//Namely, it is any number of ADDOPs and IDENTIFIERs. The
//statements in brackets are executed when the tokens are
//recognized, and hence the various tokens are printed according
//to the printToken() method.
void Program() :
{Token t;}
{
    (
     t = <BEGIN>      {printToken(t, "<BEGIN>");}
     |
     t = <END>      {printToken(t, "<END>");}
     |
     t = <KEYWORD>    {printToken(t, "<KEYWORD>");}
     |
     t = <MULTOP>     {printToken(t, "<MULTOP>");}
     |
     t = <ADDOP>      {printToken(t, "<ADDOP>");}
     |
     t = <ASSIGNOP>      {printToken(t, "<ASSIGNOP>");}
     |
     t = <SEMICOLON>      {printToken(t, "<SEMICOLON>");}
     |
     t = <OPENPAREN>      {printToken(t, "<OPENPAREN>");}
     |
     t = <CLOSEPAREN>      {printToken(t, "<CLOSEPAREN>");}
     |
     t = <IDENTIFIER> {printToken(t, "<IDENTIFIER>");}
    )*
}
