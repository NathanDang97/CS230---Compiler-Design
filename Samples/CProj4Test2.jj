// Name: Ngu Dang (Nathan)

/*
   NOTES ON USING THIS FILE:
      (1) Store in a convenient directory.
      (2) At the command line, type "javacc Parser.jj"
      (3) At the command line, type "javac Parser.java"
      (4) To run, type "java Parser <inputfilename>".
   It's easy to leave out step 3! The file Parser.java is
   automatically generated by javacc, but is *not* automatically
   compiled by it!
   Note: The *name* of the file Parser.java comes from the name of
   the *class* Parser in this file. Even if you change the name
   of this file, unless you change the name of the Parser class below,
   javacc will still generate a file entitled Parser.java.
 */

PARSER_BEGIN(Parser)

import java.io.*;
import java.util.*;

public class Parser {
   StringBuilder sb = new StringBuilder();

   public static void main(String[] args) throws ParseException, FileNotFoundException {
      Parser parser = new Parser(new FileInputStream(args[0]));
      parser.Input();
   }

   public static void indent(int n) {
      for (int i = 0; i < n; ++i) {
         System.out.print(" ");
         System.out.print(" ");
      }
   }

   public static void toString(AST t, int level) {
        // if its left/right leaf is null, print "-"
        if (t == null) {
            indent(level);
            System.out.println("-");
            return;
        }
        indent(level);
        System.out.println(t.value);
        // if it's a leaf, return
        if (t.left == null && t.right == null) return;
        toString(t.left, level + 1);
        toString(t.right, level + 1);
    }
}

abstract class AST {
    String value;
    AST left, right;
}
class Leaf extends AST {
    Leaf(String val) {
        this.value = val;
        this.left = null;
        this.right = null;
    }
}
class Node extends AST {
    Node(String val, AST l, AST r) {
        this.value = val; 
        this.left = l; 
        this.right = r;
    }
}

PARSER_END(Parser)

 /* BEGIN: Specification of tokens */

 SKIP: 
 {
   " "
   | "\t"
   | "\n"
   | "\r"
 }

 TOKEN:
 {
    <KEYWORD: "void" | "main">
    | <ADDOP: "+" | "-" >
    | <MULTOP: "*" | "/" | "%">
    | <ASSIGNOP: "=">
    | <SEMICOLON: ";">
    | <OPENPAREN: "(">
    | <CLOSEPAREN: ")">
    | <BEGIN: "{">
    | <END: "}">
    | <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
    | <LETTER: ["a"-"z"]>
    | <DIGIT: ["0"-"9"]>
 }

/* END: Specification of tokens */

/* BEGIN: Specification of Language */

void Input():
{ AST tree = null; }
{
   { 
      System.out.println("Parsing the input file..."); 
      System.out.println("-------------------------");
   }
   tree = program() <EOF>
   {
      toString(tree, 1);
   }
}

// <program> → void main () <block>
AST program() :
{ 
   AST tree;
   Token t;
   int lv = 1;
   indent(lv);
   System.out.println("<program>");
}
{
   t = <KEYWORD> { 
      indent(lv);
      System.out.println(t.image); 
   } 
   t = <KEYWORD> {
      indent(lv); 
      System.out.println(t.image);  
   } 
   t = <OPENPAREN> {
      indent(lv);     
      System.out.print(t.image); 
   }
   t = <CLOSEPAREN> { 
      System.out.println(t.image); 
   }
   tree = block(lv)
   { return tree; }
} 

// <block> → { <optional_statements>? }
AST block(int n) :
{ 
   AST tree = null;
   Token t;
   int lv = n;
   indent(lv);
   System.out.println("<block>");
}
{
   t = <BEGIN> {
      indent(lv);
      System.out.println(t.image);
   } 
   (tree = optional_statements(lv + 1))? 
   t = <END> {
      indent(lv);
      System.out.println(t.image);
   }
   { return tree; }
}

// <optional_statements>  → <statement_list>
AST optional_statements(int n) :
{ 
   AST tree;
   int lv = n;
   indent(lv);
   System.out.println("<optional_statements>");
}
{
   tree = statement_list(lv + 1)
   { return tree; }
}

// <statement_list>  → <statement> ( <statement> )* 
AST statement_list(int n) :
{
   AST tree, op, r;
   int lv = n;
   indent(lv);
   System.out.println("<statement_list>"); 
}
{
   tree = statement(lv + 1) (r = statement(lv + 1) {
      op = new Node(";", tree, r);
      tree = op;
   })*
   { return tree; }
}

// <statement>  → <variable> <assignop> <expression>;
AST statement(int n) :
{
   AST tree, op, r;
   Token t1, t2;
   int lv = n;
   indent(lv);
   System.out.println("<statement>"); 
}
{
   tree = variable(lv + 1) 
   t1 = <ASSIGNOP> {
      indent(lv + 1);
      System.out.println(t1.image);
   } 
   r = expression(lv + 1) 
   t2 = <SEMICOLON> {
      indent(lv);
      System.out.println(t2.image);
   }
   {
      op = new Node(t1.image, tree, r);
      tree = op;
   }
   { return tree; }
}

// <variable> → <id> 
AST variable(int n) : 
{ 
   Token t;
   int lv = n;
   indent(lv);
   System.out.println("<variable>");
}
{
   t = <IDENTIFIER> {
      indent(lv + 1);
      System.out.println(t.image);
      return new Leaf(t.image);
   }
}

// <expression> → <simple_expression> 
AST expression(int n) :
{
   AST tree;
   int lv = n;
   indent(lv);
   System.out.println("<expression>"); 
}
{
   tree = simple_expression(lv + 1)
   { return tree; }
}

// <simple_expression>  → <term> ( <addop> <term> ) * 
AST simple_expression(int n) :
{ 
   AST tree, op, r;
   Token t;
   int lv = n;
   indent(lv);
   System.out.println("<simple_expression>");
}
{
   tree = term(lv + 1)
   (t = <ADDOP> {
       indent(lv + 1);
       System.out.println(t.image);
    } 
    r = term(lv + 1) {
        op = new Node(t.image, tree, r);
        tree = op;
    })*
    { return tree; }
}

// <term> →   <factor> (<mulop> <factor>) * 
AST term(int n) :
{
   AST tree, op, r;
   Token t;
   int lv = n;
   indent(lv);
   System.out.println("<term>"); 
}
{
   tree = factor(lv + 1) 
   (t = <MULTOP> {
       indent(lv + 1);
       System.out.println(t.image);
    } 
    r = factor(lv + 1) {
        op = new Node(t.image, tree, r);
        tree = op;
    })*
    { return tree; }
}

// <factor>  → <id> |  (<expression>) |  <num>
AST factor(int n) :
{
   AST tree;
   Token t;
   int lv = n;
   indent(lv);
   System.out.println("<factor>");
}
{
   t = <IDENTIFIER> {
      indent(lv + 1);
      System.out.println(t.image);
      return new Leaf(t.image);
   }
   | 
   t = <OPENPAREN> {
      indent(lv + 1);
      System.out.println(t.image);
   }
   tree = expression(lv + 1) 
   t = <CLOSEPAREN> {
      indent(lv + 1);
      System.out.println(t.image);
   }
   { return tree; }
   | 
   t = <DIGIT> {
      indent(lv + 1);
      System.out.println(t.image);
      return new Leaf(t.image);
   }
}

/* END: Specification of Language */
