// Name: Ngu Dang (Nathan)

/*
   NOTES ON USING THIS FILE:
      (1) Store in a convenient directory.
      (2) At the command line, type "javacc Parser.jj"
      (3) At the command line, type "javac Parser.java"
      (4) To run, type "java Parser <inputfilename>".
   It's easy to leave out step 3! The file Parser.java is
   automatically generated by javacc, but is NOT automatically
   compiled by it!
   Note: The "name" of the file Parser.java comes from the name of
   the "class" Parser in this file. Even if you change the name
   of this file, unless you change the name of the Parser class below,
   javacc will still generate a file entitled Parser.java.
 */

 /*
    What this file does: after receiving this file, javacc will produce a .java file (Parser.java)
    which not only prints tokens but also prints out each successful reduction. The grammatical symbols
    are nicely indented so that the structure of the parse tree is evident in the output 
 */

PARSER_BEGIN(Parser)

import java.io.*;
import java.util.*;

public class Parser {
   public static class ASTNode {
      String value;
      ASTNode left;
      ASTNode right;
   }
   public static void main(String[] args) throws ParseException, FileNotFoundException {
      Parser parser = new Parser(new FileInputStream(args[0]));
      parser.Input();
   }

   public static void indent(int n) {
      for (int i = 0; i < n; ++i) {
         System.out.print(" ");
         System.out.print(" ");
      }
   }
}

PARSER_END(Parser)

 /* BEGIN: Specification of tokens */

// ignore blanks and spaces
 SKIP: 
 {
   " "
   | "\t"
   | "\n"
   | "\r"
 }

// list of tokens
 TOKEN:
 {
    <KEYWORD: "void" | "main" | "if" | "else" | "while">
    | <TYPE: "int" | "bool">
    | <RELOP: "==" | "!=" | "<" | "<=" | ">" | ">=">
    | <ADDOP: "+" | "-" | "||">
    | <MULTOP: "*" | "/" | "%" | "&&">
    | <ASSIGNOP: "=">
    | <SEMICOLON: ";">
    | <OPENPAREN: "(">
    | <CLOSEPAREN: ")">
    | <BEGIN: "{">
    | <END: "}">
    | <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
    | <LETTER: ["a"-"z"] | ["A" - "Z"]>
    | <DIGIT: ["0"-"9"]>
    | <SIGN: "+" | "-">
    | <COMMA: ",">
    | <NOT: "!">
 }

/* END: Specification of tokens */

/* 
BEGIN: Specification of language
  - Recursive decent is applied.  
  - Printing actions are embedded so that token and parse info is printed as it goes.
  - Each rule of the grammar is attached as a comment line before each corresponding function for easy reading.
  - Each function, starting from block(), will have an integer argument, say 'n', which indicates the "level/"depth" of that rule
  in the grammar, that is, n will increase by 1 when it goes one level deeper. This will help give the correct indentation for the output since the indent(int n) method will produce the spaces based on 'n'.
*/

void Input():
{ }
{
   { 
      System.out.println("Parsing the input file..."); 
      System.out.println("-------------------------");
   }
   program() <EOF>
}

// <program> → void main () <block>
ASTNode program() :
{ 
   ASTNode op = new ASTNode(); 
   ASTNode tree = new ASTNode(); 
   ASTNode r = new ASTNode();
   Token t;
   int lv = 1;
   op.value = "program";
   indent(lv);
   System.out.println("(" + op.value);
}
{
   t = <KEYWORD> t = <KEYWORD> t = <OPENPAREN> t = <CLOSEPAREN> 
   r = block(lv + 1) {
      op.left = tree;
      op.right = r;
      tree = op;
      indent(lv);
      System.out.println(")");
   }
   { return tree; }
} 

/* <block> → { <declarations> <optional_statements>? } */
ASTNode block(int n) :
{ 
   Token t;
   int lv = n; 
   // indent(lv);
   // System.out.println("<block>");
}
{
   t = <BEGIN> {
      // indent(lv);
      // System.out.println(t.image);
   }
   declarations(lv + 1)
   optional_statements(lv + 1)
   t = <END> {
      // indent(lv);
      // System.out.println(t.image);
   }
   { return null; }
}

// <declarations>  →  (<declaration>)*
ASTNode declarations(int n) :
{
   ASTNode op = new ASTNode(); 
   ASTNode tree = new ASTNode(); 
   ASTNode r = new ASTNode();
   int lv = n;
   op.value = ";";
   indent(lv);
   System.out.println("(" + op.value);
}
{
  (r = declaration(lv + 1) {
      op.left = tree;
      op.right = r;
      tree = op;
      indent(lv);
      System.out.println(")");
  })*
  { return tree; }
}

// <declaration>  →  <type> <identifier_list>; 
ASTNode declaration(int n) :
{
  ASTNode op = new ASTNode(); 
  ASTNode tree = new ASTNode(); 
  ASTNode r = new ASTNode();
  Token t;
  int lv = n;
  op.value = ":";
  indent(lv);
  System.out.println("(" + op.value);
}
{
  t = <TYPE> 
  r = identifier_list(lv + 1) {
      op.left = tree;
      op.right = r;
      tree = op;
      indent(lv);
      System.out.println(")");
  }
  t = <SEMICOLON>
  { return tree; }
}

// <identifier_list>  →  <id>  ( , <id> )*
ASTNode identifier_list(int n): 
{
  ASTNode op = new ASTNode(); 
  ASTNode tree = new ASTNode(); 
  ASTNode r = new ASTNode();
  Token t;
  int lv = n;
}
{
  t = <IDENTIFIER> (t = <COMMA> t = <IDENTIFIER>)*

  { return tree; }
}

// <optional_statements>  → <statement_list>
void optional_statements(int n) :
{ 
   int lv = n; 
   // indent(lv);
   // System.out.println("<optional_statements>");
}
{
   statement_list(lv + 1)
}

// <statement_list>  → <statement> ( <statement> )* 
void statement_list(int n) :
{
   int lv = n; 
   // indent(lv);
   // System.out.println("<statement_list>"); 
}
{
   statement(lv + 1) (statement(lv + 1))*
}

/* <statement>  → <variable> <assignop> <expression>;
                | <block>
                | if (<expression>) <statement> <else_clause>
                | while (<expression>) <statement> */
void statement(int n) :
{
   Token t;
   int lv = n; 
   // indent(lv);
   // System.out.println("<statement>"); 
}
{
   variable(lv + 1) 
   t = <ASSIGNOP> {
      // indent(lv + 1);
      // System.out.println(t.image);
   } 
   expression(lv + 1) 
   t = <SEMICOLON> {
      // indent(lv + 1);
      // System.out.println(t.image);
   }
   |
   block(lv + 1)
   |
   LOOKAHEAD(3)
   t = <KEYWORD> {
      // indent(lv + 1);
      // System.out.println(t.image);
   }
   t = <OPENPAREN> {
      // indent(lv + 1);
      // System.out.println(t.image);
   }
   expression(lv + 1)
   t = <CLOSEPAREN> {
      // indent(lv + 1);
      // System.out.println(t.image);
   }
   statement(lv + 1)
   else_clause(lv + 1)
   |
   t = <KEYWORD> {
      // indent(lv + 1);
      // System.out.println(t.image);
   }
   t = <OPENPAREN> {
      // indent(lv + 1);
      // System.out.println(t.image);
   }
   expression(lv + 1)
   t = <CLOSEPAREN> {
      // indent(lv + 1);
      // System.out.println(t.image);
   }
   statement(lv + 1)
}

// <else_clause>  →  ( else <statement> )? 
void else_clause(int n) :
{
  Token t;
  int lv = n;
  // indent(lv);
  // System.out.println("<else_clause>");
}
{
  (LOOKAHEAD(2)
  t = <KEYWORD> {
    // indent(lv + 1);
    // System.out.println(t.image);
  }
  statement(lv + 1))?
}

// <variable> → <id> 
void variable(int n) : 
{ 
   Token t;
   int lv = n; 
   // indent(lv);
   // System.out.println("<variable>");
}
{
   t = <IDENTIFIER> {
      // indent(lv + 1);
      // System.out.println(t.image);
   }
}

// <expression> -> <simple_expression> <relopclause>
void expression(int n) :
{
   int lv = n; 
   // indent(lv);
   // System.out.println("<expression>"); 
}
{
   simple_expression(lv + 1)
   relopclause(lv + 1)
}

// <relopclause> -> <relop> <simple_expression> | ε ([<relop> <simple_expression>]) 
void relopclause(int n) :
{
   Token t;
   int lv = n;
   // indent(lv);
   // System.out.println("<relopclause>");
}
{
   [t = <RELOP> {
      indent(lv + 1);
      System.out.println(t.image);
    }
    simple_expression(lv + 1)]
}


/* <simple_expression>  → <term> ( <addop> <term> ) * 
                        | <sign> <term> */
void simple_expression(int n) :
{ 
   Token t;
   int lv = n; 
   // indent(lv);
   // System.out.println("<simple_expression>");
}
{
   term(lv + 1)
   (t = <ADDOP> {
       // indent(lv + 1);
       // System.out.println(t.image);
    } 
    term(lv + 1)
   )*
   |
   t = <SIGN> {
      // indent(lv + 1);
      // System.out.println(t.image);
   }
   term(lv + 1)
}

// <term> →   <factor> (<mulop> <factor>) * 
void term(int n) :
{
   Token t;
   int lv = n; 
   // indent(lv);
   // System.out.println("<term>"); 
}
{
   factor(lv + 1) 
   (t = <MULTOP> {
       // indent(lv + 1);
       // System.out.println(t.image);
    } 
    factor(lv + 1)
   )*
}

// <factor>  → <id> |  (<expression>) |  <num> | !<factor>
void factor(int n) :
{
   Token t;
   int lv = n; 
   // indent(lv);
   // System.out.println("<factor>");
}
{
   t = <IDENTIFIER> {
      // indent(lv + 1);
      // System.out.println(t.image);
   }
   | 
   t = <OPENPAREN> {
      // indent(lv + 1);
      // System.out.println(t.image);
   }
   expression(lv + 1) 
   t = <CLOSEPAREN> {
      // indent(lv + 1);
      // System.out.println(t.image);
   }
   | 
   t = <DIGIT> {
      // indent(lv + 1);
      // System.out.println(t.image);
   }
   |
   t = <NOT> {
      // indent(lv + 1);
      // System.out.println(t.image);
   }
   factor(lv + 1)
}

/* END: Specification of Language */
