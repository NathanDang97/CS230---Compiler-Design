// Name: Ngu Dang (Nathan)

/*
   NOTES ON USING THIS FILE:
      (1) Store in a convenient directory.
      (2) At the command line, type "javacc Parser.jj"
      (3) At the command line, type "javac Parser.java"
      (4) To run, type "java Parser <inputfilename>".
   It's easy to leave out step 3! The file Parser.java is
   automatically generated by javacc, but is NOT automatically
   compiled by it!
   Note: The "name" of the file Parser.java comes from the name of
   the "class" Parser in this file. Even if you change the name
   of this file, unless you change the name of the Parser class below,
   javacc will still generate a file entitled Parser.java.
 */

 /*
    What this file does: after receiving this file, javacc will produce a .java file (Parser.java)
    which will build an Abstract Syntax Tree (AST) based on the given grammar. The Parser.java file 
    will also print the tree with nice indentation and easy to read. Finally, the Parser will return
    the AST instead of "void" as a preliminary for the last part of the project, the code generator
 */

PARSER_BEGIN(Parser)

import java.io.*;
import java.util.*;

public class Parser {
   public static void main(String[] args) throws ParseException, FileNotFoundException {
      Parser parser = new Parser(new FileInputStream(args[0]));
      AST tree = parser.Input();
      System.out.println("Parsing the input file..."); 
      System.out.println("-------------------------");
      toString(tree, 1);
   }

   // indentation
   public static void indent(int n) {
      for (int i = 0; i < n; ++i) {
         System.out.print(" ");
         System.out.print(" ");
         System.out.print(" ");
      }
   }

    // print the tree
    public static void toString(AST t, int level) {
        // if its left/right leaf is null, print "-"
        if (t == null) {
            indent(level);
            System.out.println("-");
            return;
        }
        indent(level);
        System.out.println(t.value);
        // if it's a leaf, return
        if (t.left == null && t.right == null) return;
        toString(t.left, level + 1);
        toString(t.right, level + 1);
    }
}

abstract class AST {
    String value;
    AST left, right;
}
class Leaf extends AST {
    Leaf(String val) {
        this.value = val;
        this.left = null;
        this.right = null;
    }
}
class Node extends AST {
    Node(String val, AST l, AST r) {
        this.value = val; 
        this.left = l; 
        this.right = r;
    }
}

PARSER_END(Parser)

// skip blanks & spaces
 SKIP: 
 {
   " "
   | "\t"
   | "\n"
   | "\r"
 }

// tokens inside the current grammars
 TOKEN:
 {
    <KEYWORD: "void" | "main" | "if" | "else" | "while" | "printf">
    | <TYPE: "int" | "bool">
    | <RELOP: "==" | "!=" | "<" | "<=" | ">" | ">=">
    | <ADDOP: "+" | "-" | "||">
    | <SIGN: "+" | "-">
    | <MULTOP: "*" | "/" | "%" | "&&">
    | <ASSIGNOP: "=">
    | <SEMICOLON: ";">
    | <OPENPAREN: "(">
    | <CLOSEPAREN: ")">
    | <BEGIN: "{">
    | <END: "}">
    | <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
    | <LETTER: ["a"-"z"] | ["A" - "Z"]>
    | <DIGIT: ["0"-"9"]>
    | <COMMA: ",">
    | <NOT: "!">
 }

// return the AST after parsing the input file
AST Input() :
{ 
    AST tree = null; 
}
{
   tree = program() <EOF>
   {
      return tree;
   }
}

/* 
BEGIN: Specification of language
  - Recursive decent is applied.  
  - The AST will be built during recursive decent
  - Each operator should have 2 children except for "block" and "!" which can have one child
  - The empty child will be printed as "-"
*/

// <program> → void main () <block>
AST program() :
{ 
    AST tree;
}
{
    <KEYWORD> <KEYWORD> <OPENPAREN> <CLOSEPAREN> 
    tree = block()
    { return tree; }
} 

// <block> → { <declarations> <optional_statements>? }
AST block() :
{ 
    AST tree = null, op, l = null, r;  
}
{
    <BEGIN> 
    l = declarations() // declaration tree could be null
    (r = optional_statements() {
        op = new Node("block", l, r);
        tree = op;
    })? 
    <END>
    { return tree; }
}

// <declarations>  →  (<declaration>)*
AST declarations() :
{
    AST tleft = null, tright = null;
}
{
    (tright = declaration() {
        if (tleft != null)
            tleft = new Node(";", tleft, tright);
        else
            tleft = tright;
    })*
    { return tleft; }
}

// <declaration>  →  <type> <identifier_list>; 
AST declaration() :
{
    Token t;
    AST tree, l, op;
}
{
    t = <TYPE> { l = new Leaf(t.image); }
    tree = identifier_list() {
        op = new Node(":", l, tree);
        tree = op;
    }
    <SEMICOLON>
    { return tree; }
}

// <identifier_list>  →  <id>  ( , <id> )*
AST identifier_list(): 
{
    Token t;
    String comma;
    AST tree, op, l, r;
}
{
    t = <IDENTIFIER> { tree = new Leaf(t.image); } 
    (t = <COMMA> { comma = t.image; } 
    t = <IDENTIFIER> {
        r = new Leaf(t.image); 
        op = new Node(comma, tree, r);
        tree = op;
    })*
    { return tree; }
}

// <optional_statements>  → <statement_list>
AST optional_statements() :
{ 
    AST tree;
}
{
    tree = statement_list()
    { return tree; }
}

// <statement_list>  → <statement> ( <statement> )* 
AST statement_list() :
{
    AST tree, op, r;
}
{
    tree = statement() (r = statement() {
        op = new Node(";", tree, r);
        tree = op;
    })*
    { return tree; }
}

/* <statement>  → <variable> <assignop> <expression>;
                | <block>
                | if (<expression>) <statement> <else_clause>
                | while (<expression>) <statement>
                | printf(<id>); */
AST statement() :
{
    Token t;
    Token t1, t2;
    AST tree, op, l, r; 
    AST r1, r2; // two possible right child for "if" op
}
{
    tree = variable() t = <ASSIGNOP> r = expression() <SEMICOLON> {
        op = new Node(t.image, tree, r);
        tree = op;
    }
    { return tree; }
    |
    tree = block()
    { return tree; }
    |
    LOOKAHEAD(3)
    t = <KEYWORD> <OPENPAREN> l = expression() <CLOSEPAREN> r1 = statement() 
    r2 = else_clause(r1) {
        /* if the else clause is not null, attach it to the right of "if" op
           the left child of else will be the block executing when the condition of "if" is true (r1)
           the right child of else will be the block executing when that codition is false (r2) 
           the else_clause() method take r1 as an argument so that r1 can be used to attach to "else" op */
        if (r2 != null) {
            op = new Node(t.image, l, r2);
            tree = op;
        }
        // if else clause is null, the right child of "if" op is the block r1
        else {
            op = new Node(t.image, l, r1);
            tree = op;
        }
    }
    { return tree; }
    |
    // "while" op is analogous to second case of "if" op
    LOOKAHEAD(3)
    t = <KEYWORD> <OPENPAREN> l = expression() <CLOSEPAREN> r1 = statement() {
        op = new Node(t.image, l, r1);
        tree = op;
    }
    { return tree; }
    |
    t = <KEYWORD> { l = new Leaf(t.image); } <OPENPAREN> tree = variable() <CLOSEPAREN> <SEMICOLON> {
        op = new Node("()", l, tree);
        tree = op;
    }
    { return tree; }
}

// <else_clause>  →  ( else <statement> )? 
AST else_clause(AST left) :
{
    Token t;
    AST tree = null, op, r;
}
{
    (LOOKAHEAD(2)
    t = <KEYWORD> r = statement() {
        op = new Node(t.image, left, r); // attach r1 (above) to the left of "else" op
        tree = op;
    })?
    { return tree; }
}

// <variable> → <id> 
AST variable() : 
{ 
    Token t;
}
{
    t = <IDENTIFIER> { return new Leaf(t.image); }
}

// <expression> -> <simple_expression> <relopclause>
AST expression() :
{
    AST tree, r;
}
{
    /* if there exists a relop-clause, the simple expression to the left of relop will be passed to
    relopclause method so that it can attach that simple expression as its left child. */
    tree = simple_expression() r = relopclause(tree) {
        if (r != null) tree = r;
    }
    { return tree; }
}

// <relopclause> -> <relop> <simple_expression> | ε  
AST relopclause(AST left) :
{
    Token t;
    AST tree = null, op;
}
{
    [t = <RELOP> tree = simple_expression() {
        /* create a new node with the value is the relop, the left child is the simple
        expression from the expression() method above and the right child is the other
        simple expression in the rule */
        op = new Node(t.image, left, tree); 
        tree = op;
    }]
    { return tree; }
}


/* <simple_expression>  → <term> ( <addop> <term> ) * 
                        | <sign> <term> */
AST simple_expression() :
{ 
    Token t;
    AST tree, op, r;
}
{
    tree = term() (t = <ADDOP> r = term() {
        op = new Node(t.image, tree, r);
        tree = op;
    })*
    { return tree; }
    |
    <SIGN> tree = term() // skip for now
    { return null; }
}

// <term> →   <factor> (<mulop> <factor>) * 
AST term() :
{
    Token t;
    AST tree, op, r;
}
{
    tree = factor() (t = <MULTOP> r = factor() {
        op = new Node(t.image, tree, r);
        tree = op;
    })*
    { return tree; }
}

// <factor>  → <id> |  (<expression>) |  <num> | !<factor>
AST factor() :
{
    Token t;
    AST tree, op;
}
{
    t = <IDENTIFIER> { return new Leaf(t.image); }
    | 
    <OPENPAREN> tree = expression() <CLOSEPAREN>
    { return tree; }
    | 
    t = <DIGIT> { return new Leaf(t.image); }
    |
    t = <NOT> tree = factor() {
        op = new Node(t.image, null, tree);
        tree = op;
    }
    { return tree; }
}

/* END: Specification of language 
   For testing:
   - input0.txt: sample code given in part 1 (has assignment statements only)
   - input1,2.txt: sample codes given in part 3
   - input3,4.txt: sample codes I wrote
   - input5.txt: sample code given in part 4
*/