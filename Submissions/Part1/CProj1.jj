// Name: Ngu Dang (Nathan)

/*
   NOTES ON USING THIS FILE:
      (1) Store in a convenient directory.
      (2) At the command line, type "javacc Lexer.jj"
      (3) At the command line, type "javac Lexer.java"
      (4) To run, type "java Lexer <inputfilename>".
   It's easy to leave out step 3! The file Lexer.java is
   automatically generated by javacc, but is *not* automatically
   compiled by it!
   NB: The *name* of the file Lexer.java comes from the name of
   the *class* Lexer in this file. Even if you change the name
   of this file, unless you change the name of the Lexer class below,
   javacc will still generate a file entitled Lexer.java.
 */

PARSER_BEGIN(Lexer)

import java.io.*;
import java.util.*;

public class Lexer {

   public static void main(String[] args) throws ParseException, FileNotFoundException {
      Lexer parser = new Lexer(new FileInputStream(args[0]));
      parser.Input();
   }

   public static void printToken(Token t, String type) {
      if (type.equals("<KEYWORD>"))
        System.out.println("\t" + type + "\t\t" + t.image);
      else if (type.equals("<BEGIN>"))
        System.out.println("\t" + type + "\t\t\t" + t.image);
      else if (type.equals("<END>"))
        System.out.println("\t" + type + "\t\t\t" + t.image);
      else if (type.equals("<ADDOP>"))
        System.out.println("\t" + type + "\t\t\t" + t.image);
      else if (type.equals("<MULTOP>"))
        System.out.println("\t" + type + "\t\t" + t.image);
      else if (type.equals("<ASSIGNOP>"))
        System.out.println("\t" + type + "\t\t" + t.image);
      else if (type.equals("<SEMICOLON>"))
        System.out.println("\t" + type + "\t\t" + t.image);
      else if (type.equals("<OPENPAREN>"))
        System.out.println("\t" + type + "\t\t" + t.image);
      else if (type.equals("<CLOSEPAREN>"))
        System.out.println("\t" + type + "\t\t" + t.image);
      else if (type.equals("<IDENTIFIER>"))
        System.out.println("\t" + type + "\t\t" + t.image);
   }
}

PARSER_END(Lexer)

 /* BEGIN: Specification of tokens */

 SKIP: 
 {
   " "
   | "\t"
   | "\n"
   | "\r"
 }

 TOKEN:
 {
    <KEYWORD: "void" | "main">
    | <ADDOP: "+" | "-" >
    | <MULTOP: "*" | "/" | "%">
    | <ASSIGNOP: "=">
    | <SEMICOLON: ";">
    | <OPENPAREN: "(">
    | <CLOSEPAREN: ")">
    | <BEGIN: "{">
    | <END: "}">
    | <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
    | <LETTER: ["a"-"z"]>
    | <DIGIT: ["0"-"9"]>
 }

/* END: Specification of tokens */

/* BEGIN: Specification of Language */

void Input():
{ }
{
   { System.out.println("\t" + "Type\t\t\t" + "Lexeme"); }
   Program() <EOF>
}

// grammar: <program> --> (<token expression>)*
void Program() :
{ Token t; }
{
    (
     t = <BEGIN>      { printToken(t, "<BEGIN>"); }
     |
     t = <END>        { printToken(t, "<END>"); }
     |
     t = <KEYWORD>    { printToken(t, "<KEYWORD>"); }
     |
     t = <MULTOP>     { printToken(t, "<MULTOP>"); }
     |
     t = <ADDOP>      { printToken(t, "<ADDOP>"); }
     |
     t = <ASSIGNOP>   { printToken(t, "<ASSIGNOP>"); }
     |
     t = <SEMICOLON>  { printToken(t, "<SEMICOLON>"); }
     |
     t = <OPENPAREN>  { printToken(t, "<OPENPAREN>"); }
     |
     t = <CLOSEPAREN> { printToken(t, "<CLOSEPAREN>"); }
     |
     t = <IDENTIFIER> { printToken(t, "<IDENTIFIER>"); }
    )*
}

/* END: Specification of Language */
